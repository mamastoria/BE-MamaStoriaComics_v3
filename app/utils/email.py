import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import os
from typing import Optional, List, Union
from app.core.config import settings

def send_email(
    to_email: Union[str, List[str]],
    subject: str,
    html_content: str,
    text_content: Optional[str] = None
) -> bool:
    """
    Send an email using Gmail SMTP settings from core config.
    
    Args:
        to_email: Single email string or list of email strings
        subject: Email subject
        html_content: Check content of the email (HTML)
        text_content: Optional plain text version. If None, it will be autogenerated or ignored.
        
    Returns:
        bool: True if successful, raises Exception otherwise.
    """
    
    sender_email = settings.SMTP_USERNAME
    password = settings.SMTP_PASSWORD
    
    if not sender_email or not password:
        print("SMTP Credentials not set. Skipping email.")
        return False

    if isinstance(to_email, str):
        recipients = [to_email]
    else:
        recipients = to_email

    message = MIMEMultipart("alternative")
    message["Subject"] = subject
    message["From"] = sender_email
    message["To"] = ", ".join(recipients)
    
    # Text part
    if text_content:
        part1 = MIMEText(text_content, "plain")
        message.attach(part1)
    
    # HTML part
    part2 = MIMEText(html_content, "html")
    message.attach(part2)
    
    try:
        # Create secure connection with server and send email
        context = smtplib.ssl.create_default_context() if os.name != 'nt' else None 
        # On some windows versions create_default_context might cause issues with some proxies, 
        # but usually it's fine. keeping logic consistent with previous successful test.
        # Actually in the test script I used:
        # context = smtplib.ssl.create_default_context()
        # with smtplib.SMTP_SSL(..., context=context)
        # In notification.py I used `if os.name != 'nt'` check which is a bit weird but might be legacy compatibility from my previous thought.
        # The test script worked with `context = smtplib.ssl.create_default_context()`. I will use that.
        
        context = smtplib.ssl.create_default_context()
        
        with smtplib.SMTP_SSL(settings.SMTP_SERVER, settings.SMTP_PORT, context=context) as server:
            server.login(sender_email, password)
            server.sendmail(
                sender_email, recipients, message.as_string()
            )
        
        return True
    except Exception as e:
        print(f"Failed to send email: {str(e)}")
        raise e
